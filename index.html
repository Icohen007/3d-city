<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js City Scene - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #fps { position: absolute; top: 10px; left: 10px; color: yellow; font-family: sans-serif; } /* Basic FPS display */
    </style>
</head>
<body>
    <div id="fps">FPS: ...</div>
    <canvas id="cityCanvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // import { BufferGeometryUtils } from 'three/addons/utils/BufferGeometryUtils.js'; // Needed for merging (optional, not used in final version below for simplicity)

        let scene, camera, renderer, controls, clock;
        let sunLight, ambientLight;
        let cars = [];
        let pedestrians = [];
        let streetLights = []; // Still needed for the PointLight objects
        let trafficLights = [];
        let billboards = [];
        let timeOfDay = 0.25;
        const dayDuration = 120;

        const citySize = 100;
        const roadWidth = 8;
        const sidewalkWidth = 3;
        const buildingBlockSize = 20;
        const streetWidth = roadWidth + sidewalkWidth * 2;

        // --- Performance Monitoring ---
        let frameCount = 0;
        let lastFPSTime = 0;
        const fpsElement = document.getElementById('fps');

        // --- Optimization Settings ---
        const SHADOW_MAP_SIZE = 1024; // Reduced shadow map size
        const MAX_INSTANCED_ITEMS = 10000; // Max number of instances per InstancedMesh
        const ENABLE_INSTANCING = true; // Toggle instancing easily

        // --- Shared Materials (Optimization) ---
        const materials = {
            road: new THREE.MeshStandardMaterial({ color: 0x333333 }),
            sidewalk: new THREE.MeshStandardMaterial({ color: 0x999999 }),
            roadMarking: new THREE.MeshBasicMaterial({ color: 0xffffff }), // Basic for markings
            lamppost: new THREE.MeshStandardMaterial({ color: 0x555555 }),
            lampBulb: new THREE.MeshStandardMaterial({ color: 0xffffdd, emissive: 0x000000, emissiveIntensity: 0 }),
            benchWood: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
            benchMetal: new THREE.MeshStandardMaterial({ color: 0x666666 }),
            treeTrunk: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
            treeLeaves: new THREE.MeshStandardMaterial({ color: 0x228B22 }),
            trashCan: new THREE.MeshStandardMaterial({ color: 0x606060 }),
            hydrant: new THREE.MeshStandardMaterial({ color: 0xff0000 }),
            busStopMetal: new THREE.MeshStandardMaterial({ color: 0x777777 }),
            busStopGlass: new THREE.MeshStandardMaterial({ color: 0xeeeeff, transparent: true, opacity: 0.3, side: THREE.DoubleSide }),
            busStopRoof: new THREE.MeshStandardMaterial({ color: 0x555555 }),
            antenna: new THREE.MeshStandardMaterial({ color: 0xbbbbbb }),
            billboardFrame: new THREE.MeshBasicMaterial({ color: 0x444444 }),
            buildingColors: [ // Predefined building colors
                new THREE.MeshStandardMaterial({ color: 0xcccccc }),
                new THREE.MeshStandardMaterial({ color: 0xffccaa }),
                new THREE.MeshStandardMaterial({ color: 0xaaddff }),
                new THREE.MeshStandardMaterial({ color: 0xcfcfcf }),
                new THREE.MeshStandardMaterial({ color: 0xffeebb }),
                new THREE.MeshStandardMaterial({ color: 0xaaccaa }),
            ]
        };

        // --- Instanced Mesh Data ---
        const instanceData = {
            lamppost: { positions: [], count: 0 },
            treeTrunk: { positions: [], count: 0 },
            treeLeaves: { positions: [], scales: [], count: 0 },
            bench: { matrices: [], count: 0 },
            trashCan: { positions: [], count: 0 },
            hydrant: { positions: [], count: 0 },
            roadDash: { matrices: [], count: 0 },
        };
        let instancedMeshes = {};


        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(citySize * 0.6, citySize * 0.4, citySize * 0.6);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('cityCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 5;
            controls.maxDistance = citySize * 1.5;

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(50, 80, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = SHADOW_MAP_SIZE; // Use optimized size
            sunLight.shadow.mapSize.height = SHADOW_MAP_SIZE;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 300;
            // Optimize shadow frustum (can be tighter if city is always centered)
            const shadowCamSize = citySize * 1.1;
            sunLight.shadow.camera.left = -shadowCamSize;
            sunLight.shadow.camera.right = shadowCamSize;
            sunLight.shadow.camera.top = shadowCamSize;
            sunLight.shadow.camera.bottom = -shadowCamSize;
            scene.add(sunLight);
            scene.add(sunLight.target);

            // --- Create City Elements ---
            createGround();
            createCityLayout(); // This will now populate instanceData
            setupInstancedMeshes(); // Create InstancedMesh objects from instanceData
            spawnCars(25); // Reduced default
            spawnPedestrians(40); // Reduced default

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // --- Geometry & Mesh Creation (Modified for Instancing/Optimization) ---

        function createGround() {
            const groundSize = citySize * 3;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x505050, side: THREE.DoubleSide }); // Slightly lighter ground
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createBuilding(width, height, depth, material) {
            // Re-use geometry if dimensions are common? For now, create new.
            const geometry = new THREE.BoxGeometry(width, height, depth);
            geometry.translate(0, height / 2, 0); // Move origin to base
            const building = new THREE.Mesh(geometry, material);
            building.castShadow = true;
            building.receiveShadow = true;
            // Position set externally
            return building;
        }

        function createRoadSegment(x, z, length, vertical = false) {
            // Use shared road material
            const roadGeometry = new THREE.PlaneGeometry(vertical ? roadWidth : length, vertical ? length : roadWidth);
            const road = new THREE.Mesh(roadGeometry, materials.road);
            road.rotation.x = -Math.PI / 2;
            road.position.set(x, 0, z);
            road.receiveShadow = true;
            scene.add(road);

            // Center line dashes (Add data for instancing)
            if (ENABLE_INSTANCING) {
                const dashLength = 1;
                const gapLength = 0.5;
                const numDashes = Math.floor(length / (dashLength + gapLength));
                const tempObject = new THREE.Object3D(); // Helper for matrix calculation

                for (let i = 0; i < numDashes; i++) {
                    if (instanceData.roadDash.count >= MAX_INSTANCED_ITEMS) break;
                    const offset = -length / 2 + dashLength / 2 + i * (dashLength + gapLength);
                    tempObject.position.set(vertical ? x : x + offset, 0.01, vertical ? z + offset : z);
                    tempObject.rotation.x = -Math.PI/2;
                    // No rotation needed for dashes if geometry is defined correctly
                     tempObject.scale.set(vertical ? 0.1 : dashLength, vertical ? dashLength : 0.1, 1); // Scale plane instead
                    tempObject.updateMatrix();
                    instanceData.roadDash.matrices.push(tempObject.matrix.clone());
                    instanceData.roadDash.count++;
                }
            } else { // Original non-instanced way
                const dashLength = 1;
                const gapLength = 0.5;
                const numDashes = Math.floor(length / (dashLength + gapLength));

                for (let i = 0; i < numDashes; i++) {
                    const dashGeo = new THREE.PlaneGeometry(vertical ? 0.1 : dashLength, vertical ? dashLength : 0.1);
                    const dash = new THREE.Mesh(dashGeo, materials.roadMarking);
                    dash.rotation.x = -Math.PI / 2;
                    const offset = -length / 2 + dashLength / 2 + i * (dashLength + gapLength);
                    dash.position.set(vertical ? x : x + offset, 0.01, vertical ? z + offset : z);
                    dash.receiveShadow = false;
                    scene.add(dash);
                }
            }
        }

        function createSidewalkSegment(x, z, length, width, verticalEdge = false) {
             const sidewalkGeo = new THREE.BoxGeometry(verticalEdge ? width : length, 0.1, verticalEdge ? length : width );
             const sidewalk = new THREE.Mesh(sidewalkGeo, materials.sidewalk); // Use shared material
             sidewalk.position.set(x, 0.05, z);
             sidewalk.receiveShadow = true;
             sidewalk.castShadow = false; // Sidewalks themselves don't need to cast shadows
             scene.add(sidewalk);
        }

        function createCrossing(x, z, length, vertical = false) {
            // Could potentially be instanced too, but let's keep simple for now
            const stripeWidth = 0.5;
            const stripeLength = roadWidth;
            const gap = 0.5;
            const numStripes = Math.floor(length / (stripeWidth + gap));

            for (let i = 0; i < numStripes; i++) {
                const stripeGeo = new THREE.PlaneGeometry(vertical ? stripeLength : stripeWidth, vertical ? stripeWidth : stripeLength);
                const stripe = new THREE.Mesh(stripeGeo, materials.roadMarking); // Use shared material
                stripe.rotation.x = -Math.PI / 2;
                const offset = -length / 2 + stripeWidth / 2 + i * (stripeWidth + gap);
                stripe.position.set(vertical ? x + offset : x, 0.015, vertical ? z : z + offset);
                stripe.receiveShadow = false;
                scene.add(stripe);
            }
        }

        function addLamppostInstance(x, z) {
            const postHeight = 5;
            const lightIntensity = 25;
            const lightDistance = 18;

            // Add position data for InstancedMesh
            if (instanceData.lamppost.count < MAX_INSTANCED_ITEMS) {
                instanceData.lamppost.positions.push(x, postHeight / 2, z); // Store base position
                instanceData.lamppost.count++;
            }

            // Create the actual PointLight (cannot be instanced easily)
            const pointLight = new THREE.PointLight(0xffaa44, 0, lightDistance);
            pointLight.position.set(x, postHeight, z); // Light position near top
            pointLight.castShadow = false; // Ensure shadows are off for performance
            scene.add(pointLight);

            // Store light and reference to shared bulb material for day/night cycle
            // We can't easily link an instance to a specific light's material state,
            // so the bulb mesh won't glow individually with instancing.
            // We keep the light logic for illumination.
            streetLights.push({ light: pointLight, intensity: lightIntensity });
        }

        function addBenchInstance(x, z, rotationY = 0) {
            if (instanceData.bench.count >= MAX_INSTANCED_ITEMS) return;

            const tempObject = new THREE.Object3D();
            tempObject.position.set(x, 0, z);
            tempObject.rotation.y = rotationY;
            tempObject.updateMatrix();

            instanceData.bench.matrices.push(tempObject.matrix.clone());
            instanceData.bench.count++;
        }

        function addTreeInstance(x, z) {
             const trunkHeight = 2 + Math.random() * 1;
             const trunkRadius = 0.1 + Math.random() * 0.1;
             const leavesHeight = 2 + Math.random() * 2;
             const leavesRadius = 0.8 + Math.random() * 0.4;

             // Trunk Instance Data
             if (instanceData.treeTrunk.count < MAX_INSTANCED_ITEMS) {
                 // Assume trunk geometry origin is at base for position setting
                 instanceData.treeTrunk.positions.push(x, 0, z); // Position at base
                 instanceData.treeTrunk.count++;
                 // Note: If trunk geometry has varying height/radius, need attributes or separate InstancedMeshes
             }

             // Leaves Instance Data
             if (instanceData.treeLeaves.count < MAX_INSTANCED_ITEMS) {
                 // Assume leaves geometry origin allows scaling and positioning
                 instanceData.treeLeaves.positions.push(x, trunkHeight + leavesHeight / 2 - 0.2, z); // Center of leaves mass
                 instanceData.treeLeaves.scales.push(leavesRadius, leavesHeight, leavesRadius); // Scale base cone geometry
                 instanceData.treeLeaves.count++;
             }
        }

        function addTrashCanInstance(x, z) {
            if (instanceData.trashCan.count < MAX_INSTANCED_ITEMS) {
                 // Assuming geometry origin is at base
                instanceData.trashCan.positions.push(x, 0, z);
                instanceData.trashCan.count++;
            }
        }

        function addFireHydrantInstance(x, z) {
             if (instanceData.hydrant.count < MAX_INSTANCED_ITEMS) {
                 // Assuming geometry origin is at base
                 instanceData.hydrant.positions.push(x, 0, z);
                 instanceData.hydrant.count++;
             }
        }

        // Non-Instanced Objects (Keep as is for now)
         function createTrafficLight(x, z, rotationY = 0) {
            // ... (Keep traffic light creation as individual objects, they have state)
            // ... Ensure castShadow=false for performance on small parts
            const lightGroup = new THREE.Group();
            const poleHeight = 4;
            const boxWidth = 0.4;
            const boxHeight = 1.0;
            const boxDepth = 0.3;
            const lightRadius = 0.12;

            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, poleHeight, 8);
            const pole = new THREE.Mesh(poleGeo, materials.lamppost); // Reuse material
            pole.position.y = poleHeight / 2;
            pole.castShadow = false;
            lightGroup.add(pole);

            const boxGeo = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); // Specific material okay here
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = poleHeight - boxHeight / 2;
            box.castShadow = false;
            lightGroup.add(box);

            const redLightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);
            const yellowLightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);
            const greenLightGeo = new THREE.SphereGeometry(lightRadius, 16, 8);

            // State is managed via material color, so unique materials needed per light
            const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const yellowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const greenMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

            const redLight = new THREE.Mesh(redLightGeo, redMat);
            const yellowLight = new THREE.Mesh(yellowLightGeo, yellowMat);
            const greenLight = new THREE.Mesh(greenLightGeo, greenMat);

            const lightYOffset = poleHeight - boxHeight / 2;
            const lightZOffset = boxDepth / 2 + 0.01;

            redLight.position.set(0, lightYOffset + boxHeight / 3, lightZOffset);
            yellowLight.position.set(0, lightYOffset, lightZOffset);
            greenLight.position.set(0, lightYOffset - boxHeight / 3, lightZOffset);
            redLight.castShadow = false;
            yellowLight.castShadow = false;
            greenLight.castShadow = false;

            lightGroup.add(redLight);
            lightGroup.add(yellowLight);
            lightGroup.add(greenLight);

            lightGroup.position.set(x, 0, z);
            lightGroup.rotation.y = rotationY;

            scene.add(lightGroup);

            const trafficLight = {
                 group: lightGroup,
                 lights: { red: redLight, yellow: yellowLight, green: greenLight },
                 materials: { red: redMat, yellow: yellowMat, green: greenMat },
                 state: 'red',
                 timer: Math.random() * 15
             };
            trafficLights.push(trafficLight);
            setTrafficLightState(trafficLight, 'red');
            return trafficLight;
         }

         function createBusStop(x, z, rotationY = 0) {
            // Keep as individual group, relatively few bus stops
            // Ensure castShadow=false on parts
             const stopGroup = new THREE.Group();
             const shelterWidth = 3;
             const shelterDepth = 1.5;
             const shelterHeight = 2.2;
             const postRadius = 0.05;

             const postGeo = new THREE.CylinderGeometry(postRadius, postRadius, shelterHeight, 8);
             const post1 = new THREE.Mesh(postGeo, materials.busStopMetal);
             const post2 = new THREE.Mesh(postGeo, materials.busStopMetal);
             post1.position.set(-shelterWidth / 2 + postRadius, shelterHeight / 2, -shelterDepth / 2 + postRadius);
             post2.position.set(shelterWidth / 2 - postRadius, shelterHeight / 2, -shelterDepth / 2 + postRadius);
             post1.castShadow = false;
             post2.castShadow = false;
             stopGroup.add(post1);
             stopGroup.add(post2);

             const backGeo = new THREE.PlaneGeometry(shelterWidth, shelterHeight);
             const backPanel = new THREE.Mesh(backGeo, materials.busStopGlass);
             backPanel.position.set(0, shelterHeight / 2, -shelterDepth / 2);
             backPanel.castShadow = false;
             backPanel.receiveShadow = false;
             stopGroup.add(backPanel);

             const roofGeo = new THREE.BoxGeometry(shelterWidth * 1.1, 0.1, shelterDepth * 1.1);
             const roof = new THREE.Mesh(roofGeo, materials.busStopRoof);
             roof.position.set(0, shelterHeight + 0.05, -shelterDepth/2 + 0.05);
             roof.castShadow = false; // Roof casting shadow might be okay, but disable for max perf
             stopGroup.add(roof);

             const benchWidth = shelterWidth * 0.8;
             const benchDepth = 0.4;
             const benchHeight = 0.45;
             const benchGeo = new THREE.BoxGeometry(benchWidth, 0.1, benchDepth);
             const bench = new THREE.Mesh(benchGeo, materials.sidewalk); // Reuse sidewalk grey
             bench.position.set(0, benchHeight, -shelterDepth / 2 + benchDepth / 2 + 0.1);
             bench.castShadow = false;
             stopGroup.add(bench);

             stopGroup.position.set(x, 0, z);
             stopGroup.rotation.y = rotationY;
             scene.add(stopGroup);
         }

         function createAntenna(x, y, z) {
            // Keep as individual, few antennas, disable shadows
             const antennaGroup = new THREE.Group();
             const poleHeight = 3 + Math.random() * 4;
             const poleRadius = 0.05;

             const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius * 0.8, poleHeight, 6);
             const pole = new THREE.Mesh(poleGeo, materials.antenna);
             pole.position.y = poleHeight / 2;
             pole.castShadow = false;
             antennaGroup.add(pole);

             const barLength = 0.5 + Math.random() * 0.5;
             const barGeo = new THREE.CylinderGeometry(poleRadius * 0.5, poleRadius * 0.5, barLength, 4);
             const bar1 = new THREE.Mesh(barGeo, materials.antenna);
             bar1.rotation.x = Math.PI/2;
             bar1.position.y = poleHeight * (0.6 + Math.random() * 0.3);
             bar1.castShadow = false;
             antennaGroup.add(bar1);

             const bar2 = new THREE.Mesh(barGeo, materials.antenna);
             bar2.rotation.z = Math.PI/2;
             bar2.position.y = poleHeight * (0.4 + Math.random() * 0.2);
             bar2.castShadow = false;
             antennaGroup.add(bar2);

             antennaGroup.position.set(x, y, z);
             scene.add(antennaGroup);
         }

        function createBillboard(width, height, text, textColor = '#FFFFFF', bgColor = '#2222AA') {
            const billboardGroup = new THREE.Group();

            // Canvas for Text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const resolutionFactor = 2;
            canvas.width = width * 100 * resolutionFactor;
            canvas.height = height * 100 * resolutionFactor;

            // Background
            context.fillStyle = bgColor;
            context.fillRect(0, 0, canvas.width, canvas.height);

            // --- FIX: Mirror text by scaling context ---
            context.save(); // Save default context state
            context.scale(-1, 1); // Flip horizontally

            // Text Styling
            context.fillStyle = textColor;
            context.font = `bold ${canvas.height * 0.45}px Arial`; // Slightly smaller font
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            // Draw Text (use negative x due to scale)
            context.fillText(text, -canvas.width / 2, canvas.height / 2);

            context.restore(); // Restore context state
            // --- End Fix ---

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            // Billboard Display Plane
            const planeGeo = new THREE.PlaneGeometry(width, height);
            // Use MeshBasicMaterial - always visible, no lighting needed, cheaper
            const planeMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const billboardPlane = new THREE.Mesh(planeGeo, planeMat);
            billboardPlane.receiveShadow = false; // Don't receive shadows
            billboardPlane.castShadow = false;
            billboardGroup.add(billboardPlane);

            // Frame (Optional, keep simple)
            const frameThickness = 0.1;
            const frameDepth = 0.1;
            // Frame doesn't need to be fancy, use basic material
            const frameMat = materials.billboardFrame;

            const frameTopGeo = new THREE.BoxGeometry(width + frameThickness*2, frameThickness, frameDepth);
            const frameTop = new THREE.Mesh(frameTopGeo, frameMat);
            frameTop.position.set(0, height / 2 + frameThickness / 2, -frameDepth/2);
            frameTop.castShadow = false;
            billboardGroup.add(frameTop);
            // Add other frame parts similarly... (omitted bottom/left/right for brevity, add back if needed)
             const frameBottom = new THREE.Mesh(frameTopGeo, frameMat); // Reuse geometry
             frameBottom.position.set(0, -height / 2 - frameThickness / 2, -frameDepth/2);
             frameBottom.castShadow = false;
             billboardGroup.add(frameBottom);

             const frameSideGeo = new THREE.BoxGeometry(frameThickness, height, frameDepth); // Sides geo
             const frameLeft = new THREE.Mesh(frameSideGeo, frameMat);
             frameLeft.position.set(-width / 2 - frameThickness / 2, 0, -frameDepth/2);
             frameLeft.castShadow = false;
             billboardGroup.add(frameLeft);

             const frameRight = new THREE.Mesh(frameSideGeo, frameMat);
             frameRight.position.set(width / 2 + frameThickness / 2, 0, -frameDepth/2);
             frameRight.castShadow = false;
             billboardGroup.add(frameRight);


            billboards.push(billboardGroup);
            return billboardGroup;
        }


        // --- City Layout Generation ---
        function createCityLayout() {
            const numBlocks = Math.floor(citySize / (buildingBlockSize + streetWidth));
            const cityExtent = numBlocks * (buildingBlockSize + streetWidth);

             // Roads and Sidewalks Grid
             // ... (createRoadSegment and createSidewalkSegment called here) ...
             for (let i = -numBlocks; i <= numBlocks; i++) {
                 const pos = i * (buildingBlockSize + streetWidth);
                 if(Math.abs(pos) <= citySize + streetWidth) {
                    createRoadSegment(pos, 0, citySize * 2.2, true);
                    createSidewalkSegment(pos + roadWidth/2 + sidewalkWidth/2, 0, citySize * 2.2, sidewalkWidth, true);
                    createSidewalkSegment(pos - roadWidth/2 - sidewalkWidth/2, 0, citySize * 2.2, sidewalkWidth, true);
                 }
                  if(Math.abs(pos) <= citySize + streetWidth) {
                     createRoadSegment(0, pos, citySize * 2.2, false);
                     createSidewalkSegment(0, pos + roadWidth/2 + sidewalkWidth/2, citySize * 2.2, sidewalkWidth, false);
                     createSidewalkSegment(0, pos - roadWidth/2 - sidewalkWidth/2, citySize * 2.2, sidewalkWidth, false);
                  }
             }

             // Intersections
             // ... (createCrossing and createTrafficLight called here) ...
             for (let i = -numBlocks; i <= numBlocks; i++) {
                 for (let j = -numBlocks; j <= numBlocks; j++) {
                     const crossX = i * (buildingBlockSize + streetWidth);
                     const crossZ = j * (buildingBlockSize + streetWidth);
                     createCrossing(crossX, crossZ + roadWidth/2 + 0.1, sidewalkWidth * 2, true);
                     createCrossing(crossX, crossZ - roadWidth/2 - 0.1, sidewalkWidth * 2, true);
                     createCrossing(crossX + roadWidth/2 + 0.1, crossZ, sidewalkWidth * 2, false);
                     createCrossing(crossX - roadWidth/2 - 0.1, crossZ, sidewalkWidth * 2, false);
                     const lightOffset = roadWidth / 2 + sidewalkWidth / 2;
                     createTrafficLight(crossX - lightOffset, crossZ - lightOffset, Math.PI / 4);
                     createTrafficLight(crossX + lightOffset, crossZ - lightOffset, -Math.PI / 4);
                     createTrafficLight(crossX - lightOffset, crossZ + lightOffset, Math.PI * 3 / 4);
                     createTrafficLight(crossX + lightOffset, crossZ + lightOffset, -Math.PI * 3 / 4);
                 }
             }


            // Buildings and Street Furniture
            for (let i = -numBlocks; i < numBlocks; i++) {
                for (let j = -numBlocks; j < numBlocks; j++) {
                    const blockCenterX = (i + 0.5) * (buildingBlockSize + streetWidth);
                    const blockCenterZ = (j + 0.5) * (buildingBlockSize + streetWidth);

                    // Building
                    const buildingHeight = 5 + Math.random() * (buildingBlockSize * 3); // More varied heights
                    const buildingWidth = buildingBlockSize * (0.7 + Math.random() * 0.2);
                    const buildingDepth = buildingBlockSize * (0.7 + Math.random() * 0.2);
                    const buildingMat = materials.buildingColors[Math.floor(Math.random() * materials.buildingColors.length)];
                    const building = createBuilding(buildingWidth, buildingHeight, buildingDepth, buildingMat);
                    building.position.set(blockCenterX, 0, blockCenterZ);
                    scene.add(building);

                    // Antenna (Less frequent)
                    if (Math.random() < 0.15) {
                         createAntenna(blockCenterX + (Math.random()-0.5)*buildingWidth*0.5,
                                       buildingHeight,
                                       blockCenterZ + (Math.random()-0.5)*buildingDepth*0.5);
                    }

                    // Billboard on MOST buildings (80% chance)
                    if (Math.random() < 0.8) {
                         // Adjust size based on building dimensions
                         let billboardWidth = Math.min(buildingWidth * 0.7, 15); // Cap max width
                         let billboardHeight = Math.min(buildingHeight * 0.4, billboardWidth * 0.5); // Limit height by building height and aspect ratio
                         billboardWidth = billboardHeight / 0.5; // Recalculate width based on limited height to maintain aspect ratio

                         if (billboardWidth > 1 && billboardHeight > 0.5) { // Only add if reasonably sized
                            const billboard = createBillboard(billboardWidth, billboardHeight, "Itamar");

                            // Position slightly above middle, below top edge
                            const billboardY = Math.min(buildingHeight * 0.6, buildingHeight - billboardHeight / 2 - 0.5);

                             const side = Math.floor(Math.random() * 4);
                             const offset = 0.1; // Offset from building face
                             switch(side) {
                                 case 0: // +X side
                                     billboard.position.set(blockCenterX + buildingWidth / 2 + offset, billboardY, blockCenterZ);
                                     billboard.rotation.y = -Math.PI / 2; break;
                                 case 1: // -X side
                                     billboard.position.set(blockCenterX - buildingWidth / 2 - offset, billboardY, blockCenterZ);
                                     billboard.rotation.y = Math.PI / 2; break;
                                 case 2: // +Z side
                                     billboard.position.set(blockCenterX, billboardY, blockCenterZ + buildingDepth / 2 + offset);
                                     billboard.rotation.y = Math.PI; break;
                                 case 3: // -Z side
                                     billboard.position.set(blockCenterX, billboardY, blockCenterZ - buildingDepth / 2 - offset);
                                     billboard.rotation.y = 0; break;
                             }
                             scene.add(billboard);
                         }
                    }

                    // Street furniture (populate instance data)
                    const sidewalkXPos = blockCenterX - (buildingBlockSize + streetWidth)/2 + roadWidth/2 + sidewalkWidth/2;
                    const sidewalkZPos = blockCenterZ - (buildingBlockSize + streetWidth)/2 + roadWidth/2 + sidewalkWidth/2;
                    const furnitureSpacing = buildingBlockSize / 3;

                    for (let k = 0; k < 3; k++) {
                        const offset = furnitureSpacing * k + furnitureSpacing * 0.5 - buildingBlockSize*0.5;
                        placeRandomSidewalkFurniture(blockCenterX + offset, sidewalkZPos + (buildingBlockSize + streetWidth) - sidewalkWidth, 0); // Top
                        placeRandomSidewalkFurniture(blockCenterX + offset, sidewalkZPos, Math.PI); // Bottom
                        placeRandomSidewalkFurniture(sidewalkXPos, blockCenterZ + offset, Math.PI / 2); // Left
                        placeRandomSidewalkFurniture(sidewalkXPos + (buildingBlockSize + streetWidth) - sidewalkWidth, blockCenterZ + offset, -Math.PI / 2); // Right
                    }
                }
            }
        }

        // Helper function to place random furniture (now adds instance data or creates unique objects)
        function placeRandomSidewalkFurniture(x, z, rotation) {
            const rand = Math.random();
            const sidewalkInnerEdgeOffset = sidewalkWidth / 3;
            let placeX = x, placeZ = z;

            // Adjust position inwards (same logic as before)
             if (rotation === 0) placeZ -= sidewalkInnerEdgeOffset;
             else if (rotation === Math.PI) placeZ += sidewalkInnerEdgeOffset;
             else if (rotation === Math.PI / 2) placeX += sidewalkInnerEdgeOffset;
             else if (rotation === -Math.PI / 2) placeX -= sidewalkInnerEdgeOffset;

            if (ENABLE_INSTANCING) {
                if (rand < 0.25) { addLamppostInstance(placeX, placeZ); }
                else if (rand < 0.45) { addBenchInstance(placeX, placeZ, rotation); }
                else if (rand < 0.65) { addTreeInstance(placeX, placeZ); }
                else if (rand < 0.75) { addTrashCanInstance(placeX, placeZ); }
                else if (rand < 0.85) { addFireHydrantInstance(placeX, placeZ); }
                else if (rand < 0.90) { createBusStop(placeX, placeZ, rotation); } // Keep bus stop unique
            } else { // Original non-instanced way
                 if (rand < 0.25) { /* Call original createLamppost */ } // Need original functions if not instancing
                 // ... etc for other types ...
                 // For simplicity, this example focuses on the instanced path
                 // If you need non-instanced, you'd call the original create... functions here
            }
        }

        // --- Setup Instanced Meshes ---
        function setupInstancedMeshes() {
            if (!ENABLE_INSTANCING) return;

            // Lamppost Instancing
            if (instanceData.lamppost.count > 0) {
                const postHeight = 5;
                const geometry = new THREE.CylinderGeometry(0.1, 0.1, postHeight, 8);
                // Bulb geometry (optional visual element)
                 const bulbGeo = new THREE.SphereGeometry(0.3, 16, 8);
                 bulbGeo.translate(0, postHeight + 0.1, 0); // Position bulb relative to post base

                 // Combine post and bulb into one geometry for instancing
                 // Note: This requires BufferGeometryUtils if available, or manual merging.
                 // Simplified: Just instance the post for now.
                 // const combinedGeo = BufferGeometryUtils.mergeGeometries([geometry, bulbGeo]);

                const mesh = new THREE.InstancedMesh(geometry, materials.lamppost, instanceData.lamppost.count);
                mesh.castShadow = true; // Instances can cast shadow
                mesh.receiveShadow = false; // Not usually necessary

                const tempObject = new THREE.Object3D();
                for (let i = 0; i < instanceData.lamppost.count; i++) {
                    tempObject.position.set(
                        instanceData.lamppost.positions[i*3],
                        instanceData.lamppost.positions[i*3+1],
                        instanceData.lamppost.positions[i*3+2]
                    );
                    tempObject.updateMatrix();
                    mesh.setMatrixAt(i, tempObject.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
                instancedMeshes.lamppost = mesh;
                scene.add(mesh);
            }

            // Bench Instancing
             if (instanceData.bench.count > 0) {
                 // Create bench geometry (simplified for instancing example - just seat)
                 const seatWidth = 1.5; const seatDepth = 0.4; const seatHeight = 0.4;
                 const geometry = new THREE.BoxGeometry(seatWidth, 0.1, seatDepth);
                 geometry.translate(0, seatHeight, 0); // Position seat correctly

                 // Could combine legs too, but keep simple. Use wood material.
                 const mesh = new THREE.InstancedMesh(geometry, materials.benchWood, instanceData.bench.count);
                 mesh.castShadow = false; // Disable shadow for benches

                 for (let i = 0; i < instanceData.bench.count; i++) {
                     mesh.setMatrixAt(i, instanceData.bench.matrices[i]);
                 }
                 mesh.instanceMatrix.needsUpdate = true;
                 instancedMeshes.bench = mesh;
                 scene.add(mesh);
             }

             // Tree Trunk Instancing
             if (instanceData.treeTrunk.count > 0) {
                 const trunkHeight = 2.5; // Use average height for base geo
                 const trunkRadius = 0.15;
                 // Base geometry, origin at bottom center
                 const geometry = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, trunkHeight, 8);
                 geometry.translate(0, trunkHeight/2, 0); // Translate origin to base

                 const mesh = new THREE.InstancedMesh(geometry, materials.treeTrunk, instanceData.treeTrunk.count);
                 mesh.castShadow = true;

                 const tempObject = new THREE.Object3D();
                 for (let i = 0; i < instanceData.treeTrunk.count; i++) {
                     tempObject.position.set(
                         instanceData.treeTrunk.positions[i*3],
                         instanceData.treeTrunk.positions[i*3+1],
                         instanceData.treeTrunk.positions[i*3+2]
                     );
                     // Add scaling here if trunk geo needs non-uniform scaling per instance
                     tempObject.updateMatrix();
                     mesh.setMatrixAt(i, tempObject.matrix);
                 }
                 mesh.instanceMatrix.needsUpdate = true;
                 instancedMeshes.treeTrunk = mesh;
                 scene.add(mesh);
             }

             // Tree Leaves Instancing
              if (instanceData.treeLeaves.count > 0) {
                  const baseRadius = 1; const baseHeight = 1;
                  // Base Cone geometry, origin at center. We will scale and position instances.
                  const geometry = new THREE.ConeGeometry(baseRadius, baseHeight, 8);

                  const mesh = new THREE.InstancedMesh(geometry, materials.treeLeaves, instanceData.treeLeaves.count);
                  mesh.castShadow = true;

                  const tempObject = new THREE.Object3D();
                  for (let i = 0; i < instanceData.treeLeaves.count; i++) {
                      tempObject.position.set(
                          instanceData.treeLeaves.positions[i*3],
                          instanceData.treeLeaves.positions[i*3+1],
                          instanceData.treeLeaves.positions[i*3+2]
                      );
                      tempObject.scale.set(
                          instanceData.treeLeaves.scales[i*3],
                          instanceData.treeLeaves.scales[i*3+1],
                          instanceData.treeLeaves.scales[i*3+2]
                      );
                      tempObject.updateMatrix();
                      mesh.setMatrixAt(i, tempObject.matrix);
                  }
                  mesh.instanceMatrix.needsUpdate = true;
                  instancedMeshes.treeLeaves = mesh;
                  scene.add(mesh);
              }

            // Trash Can Instancing
            if (instanceData.trashCan.count > 0) {
                const canHeight = 0.8; const canRadius = 0.25;
                const geometry = new THREE.CylinderGeometry(canRadius, canRadius * 0.9, canHeight, 16);
                geometry.translate(0, canHeight/2, 0); // Origin at base
                const mesh = new THREE.InstancedMesh(geometry, materials.trashCan, instanceData.trashCan.count);
                mesh.castShadow = false;
                const tempObject = new THREE.Object3D();
                for (let i = 0; i < instanceData.trashCan.count; i++) {
                     tempObject.position.set(
                         instanceData.trashCan.positions[i*3],
                         instanceData.trashCan.positions[i*3+1],
                         instanceData.trashCan.positions[i*3+2]
                     );
                     tempObject.updateMatrix();
                     mesh.setMatrixAt(i, tempObject.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
                instancedMeshes.trashCan = mesh;
                scene.add(mesh);
            }

            // Fire Hydrant Instancing (Simplified Geometry)
             if (instanceData.hydrant.count > 0) {
                 const mainHeight = 0.6; const mainRadius = 0.1;
                 // Simplified single cylinder for instancing example
                 const geometry = new THREE.CylinderGeometry(mainRadius, mainRadius, mainHeight, 12);
                 geometry.translate(0, mainHeight/2, 0); // Origin at base
                 const mesh = new THREE.InstancedMesh(geometry, materials.hydrant, instanceData.hydrant.count);
                 mesh.castShadow = false;
                 const tempObject = new THREE.Object3D();
                 for (let i = 0; i < instanceData.hydrant.count; i++) {
                     tempObject.position.set(
                         instanceData.hydrant.positions[i*3],
                         instanceData.hydrant.positions[i*3+1],
                         instanceData.hydrant.positions[i*3+2]
                     );
                     tempObject.updateMatrix();
                     mesh.setMatrixAt(i, tempObject.matrix);
                 }
                 mesh.instanceMatrix.needsUpdate = true;
                 instancedMeshes.hydrant = mesh;
                 scene.add(mesh);
             }

             // Road Dash Instancing
              if (instanceData.roadDash.count > 0) {
                  const geometry = new THREE.PlaneGeometry(1, 1); // Base 1x1 plane
                  const mesh = new THREE.InstancedMesh(geometry, materials.roadMarking, instanceData.roadDash.count);
                  mesh.receiveShadow = false;
                  mesh.castShadow = false;

                  for (let i = 0; i < instanceData.roadDash.count; i++) {
                      mesh.setMatrixAt(i, instanceData.roadDash.matrices[i]);
                  }
                  mesh.instanceMatrix.needsUpdate = true;
                  instancedMeshes.roadDash = mesh;
                  scene.add(mesh);
              }


        }


        // --- Dynamic Elements (Cars, Pedestrians) ---

        function createCar() {
            // Keep cars as individual objects for unique movement/headlights
            // Ensure headlight spotlights do NOT cast shadows
            const carGroup = new THREE.Group();
            // ... (car geometry setup - use shared mats where possible) ...
            const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xffa500, 0x808080, 0xffffff, 0x000000, 0x00ffff, 0xff00ff];
            const carColor = colors[Math.floor(Math.random() * colors.length)];
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: carColor }); // Unique color per car

            const bodyHeight = 0.6; const bodyWidth = 1.0; const bodyLength = 1.8;
            const bodyGeometry = new THREE.BoxGeometry(bodyLength, bodyHeight, bodyWidth);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true; // Cars cast shadows
            body.position.y = bodyHeight / 2;
            carGroup.add(body);

            const roofHeight = 0.4; const roofWidth = bodyWidth * 0.8; const roofLength = bodyLength * 0.6;
            const roofGeometry = new THREE.BoxGeometry(roofLength, roofHeight, roofWidth);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial); // Same color
            roof.position.y = bodyHeight + roofHeight / 2;
            roof.position.x = -bodyLength * 0.1;
            roof.castShadow = true; // Roof casts shadow
            carGroup.add(roof);

            // Headlights (visual mesh)
            const headlightGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.1, 16);
            const headlightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000 }); // Material for bulb appearance
            const headlightL = new THREE.Mesh(headlightGeo, headlightMat.clone()); // Clone for independent emissive control
            const headlightR = new THREE.Mesh(headlightGeo, headlightMat.clone());
            headlightL.rotation.z = Math.PI/2; headlightR.rotation.z = Math.PI/2;
            headlightL.position.set(bodyLength/2, bodyHeight/2, bodyWidth/3);
            headlightR.position.set(bodyLength/2, bodyHeight/2, -bodyWidth/3);
            headlightL.castShadow = false; headlightR.castShadow = false;
            carGroup.add(headlightL); carGroup.add(headlightR);

            // Headlight SpotLights (actual light source)
            const spotLightIntensity = 60;
            const spotDistance = 25;
            const spotAngle = Math.PI/7;
            const headLightLSource = new THREE.SpotLight(0xffffcc, 0, spotDistance, spotAngle, 0.4, 1.2);
            headLightLSource.castShadow = false; // <<< NO SHADOWS FOR SPOTLIGHTS
            headLightLSource.position.set(bodyLength/2, bodyHeight/2, bodyWidth/3);
            headLightLSource.target.position.set(bodyLength/2 + 5, bodyHeight/2, bodyWidth/3); // Initial target
            carGroup.add(headLightLSource); carGroup.add(headLightLSource.target);

            const headLightRSource = new THREE.SpotLight(0xffffcc, 0, spotDistance, spotAngle, 0.4, 1.2);
            headLightRSource.castShadow = false; // <<< NO SHADOWS FOR SPOTLIGHTS
            headLightRSource.position.set(bodyLength/2, bodyHeight/2, -bodyWidth/3);
            headLightRSource.target.position.set(bodyLength/2 + 5, bodyHeight/2, -bodyWidth/3); // Initial target
            carGroup.add(headLightRSource); carGroup.add(headLightRSource.target);

            const car = {
                mesh: carGroup,
                headlightMaterials: [headlightL.material, headlightR.material],
                headlights: [headLightLSource, headLightRSource],
                headlightIntensity: spotLightIntensity,
                speed: 6 + Math.random() * 8,
                direction: Math.random() < 0.5 ? 1 : -1,
                axis: Math.random() < 0.5 ? 'x' : 'z',
                laneOffset: (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 4),
                pathLimit: citySize * 1.1
            };

             // Initial positioning (same logic)
             const numBlocks = Math.floor(citySize / (buildingBlockSize + streetWidth));
             const streetIndex = Math.floor(Math.random() * (2 * numBlocks + 1)) - numBlocks;
             const streetPos = streetIndex * (buildingBlockSize + streetWidth);
             if (car.axis === 'x') {
                 car.mesh.position.z = streetPos + car.laneOffset * car.direction;
                 car.mesh.position.x = (Math.random() - 0.5) * car.pathLimit * 2;
                 if (car.direction < 0) car.mesh.rotation.y = Math.PI;
             } else {
                 car.mesh.position.x = streetPos + car.laneOffset * car.direction;
                 car.mesh.position.z = (Math.random() - 0.5) * car.pathLimit * 2;
                 car.mesh.rotation.y = Math.PI / 2 * -car.direction;
             }
             car.mesh.position.y = 0.01; // Keep slightly above ground

             // Manually update target positions after setting car position
            car.headlights.forEach(light => {
                light.target.parent = scene; // Ensure target is in world space
                if(car.axis === 'x') light.target.position.set(car.mesh.position.x + 5 * car.direction, light.position.y, car.mesh.position.z + light.position.z);
                else light.target.position.set(car.mesh.position.x + light.position.x, light.position.y, car.mesh.position.z + 5 * car.direction);
                light.target.updateMatrixWorld();
            });


            scene.add(carGroup);
            return car;
        }

        function spawnCars(count) { for (let i = 0; i < count; i++) cars.push(createCar()); }

        function updateCars(deltaTime) {
            const limit = citySize * 1.1;
            cars.forEach(car => {
                // Basic movement logic (same as before)
                if (car.axis === 'x') {
                    car.mesh.position.x += car.speed * car.direction * deltaTime;
                    if (car.direction > 0 && car.mesh.position.x > limit) car.mesh.position.x = -limit;
                    else if (car.direction < 0 && car.mesh.position.x < -limit) car.mesh.position.x = limit;
                } else {
                    car.mesh.position.z += car.speed * car.direction * deltaTime;
                    if (car.direction > 0 && car.mesh.position.z > limit) car.mesh.position.z = -limit;
                    else if (car.direction < 0 && car.mesh.position.z < -limit) car.mesh.position.z = limit;
                }

                // Update headlight target positions continuously
                car.headlights.forEach(light => {
                     if (car.axis === 'x') {
                         light.target.position.x = car.mesh.position.x + 5 * car.direction;
                         light.target.position.z = car.mesh.position.z + light.position.z; // Use light's local Z relative to car's world Z
                     } else {
                         light.target.position.x = car.mesh.position.x + light.position.x; // Use light's local X relative to car's world X
                         light.target.position.z = car.mesh.position.z + 5 * car.direction;
                     }
                    // Ensure target's Y is correct relative to world (should be same height as light source)
                    light.target.position.y = car.mesh.position.y + light.position.y;
                    light.target.updateMatrixWorld();
                });
            });
        }

        function createPedestrian() {
            // Keep pedestrians as individual objects for state/movement
            const height = 1.6 + (Math.random() - 0.5) * 0.2;
            const radius = 0.15;
            const geometry = new THREE.CapsuleGeometry(radius, height - 2 * radius, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(Math.random() * 0.8, Math.random() * 0.8, Math.random() * 0.8)});
            const pedestrianMesh = new THREE.Mesh(geometry, material);
            pedestrianMesh.castShadow = false; // <<< PEDESTRIANS DON'T CAST SHADOWS
            pedestrianMesh.position.y = height / 2; // Adjust base

             const pedestrian = { /* ... (same properties as before) ... */
                 mesh: pedestrianMesh,
                 speed: 0.8 + Math.random() * 0.7,
                 direction: Math.random() < 0.5 ? 1 : -1,
                 axis: Math.random() < 0.5 ? 'x' : 'z',
                 pathLimit: citySize * 1.1,
                 sidewalkOffset: (Math.random() - 0.5) * (sidewalkWidth * 0.6),
                 state: 'walking',
                 waitTimer: 0,
                 crossingTarget: null,
                 currentSidewalkPos: 0
             };
             // Initial positioning (same logic as before)
             const numBlocks = Math.floor(citySize / (buildingBlockSize + streetWidth));
             const streetIndex = Math.floor(Math.random() * (2 * numBlocks + 1)) - numBlocks;
             const streetPos = streetIndex * (buildingBlockSize + streetWidth);
             const sidewalkEdge = roadWidth / 2 + sidewalkWidth / 2;
             if (pedestrian.axis === 'x') {
                 pedestrian.currentSidewalkPos = streetPos + (Math.random() < 0.5 ? -1 : 1) * sidewalkEdge;
                 pedestrian.mesh.position.z = pedestrian.currentSidewalkPos + pedestrian.sidewalkOffset;
                 pedestrian.mesh.position.x = (Math.random() - 0.5) * pedestrian.pathLimit * 2;
                 pedestrian.mesh.rotation.y = pedestrian.direction > 0 ? 0 : Math.PI;
             } else {
                 pedestrian.currentSidewalkPos = streetPos + (Math.random() < 0.5 ? -1 : 1) * sidewalkEdge;
                 pedestrian.mesh.position.x = pedestrian.currentSidewalkPos + pedestrian.sidewalkOffset;
                 pedestrian.mesh.position.z = (Math.random() - 0.5) * pedestrian.pathLimit * 2;
                 pedestrian.mesh.rotation.y = pedestrian.direction > 0 ? -Math.PI / 2 : Math.PI/2;
             }
             pedestrian.mesh.position.y = height / 2;

             scene.add(pedestrianMesh);
             return pedestrian;
         }

        function spawnPedestrians(count) { for (let i = 0; i < count; i++) pedestrians.push(createPedestrian()); }

        function updatePedestrians(deltaTime) { /* ... (Keep existing pedestrian update logic) ... */
             const limit = citySize * 1.1;
             const crossingSpeedFactor = 0.8;

             pedestrians.forEach(p => {
                 switch (p.state) {
                     case 'walking':
                         let currentPos, nextPos;
                         const lookAheadDist = 1.0;
                         if (p.axis === 'x') {
                             p.mesh.position.x += p.speed * p.direction * deltaTime;
                             currentPos = p.mesh.position.x; nextPos = currentPos + p.direction * lookAheadDist;
                         } else {
                             p.mesh.position.z += p.speed * p.direction * deltaTime;
                             currentPos = p.mesh.position.z; nextPos = currentPos + p.direction * lookAheadDist;
                         }
                         const streetCrossPos = Math.round(nextPos / (buildingBlockSize + streetWidth)) * (buildingBlockSize + streetWidth);
                         const distToIntersection = Math.abs(nextPos - streetCrossPos);
                         const onSidewalkNearIntersection = distToIntersection < (roadWidth / 2 + sidewalkWidth);

                         if (onSidewalkNearIntersection && Math.random() < 0.002) {
                             p.state = 'waiting'; p.waitTimer = 1 + Math.random() * 4;
                             const curbOffset = (roadWidth / 2 + sidewalkWidth * 0.2) * p.direction;
                             if (p.axis === 'x') p.mesh.position.x = streetCrossPos - curbOffset;
                             else p.mesh.position.z = streetCrossPos - curbOffset;
                         } else {
                            if (p.direction > 0 && currentPos > limit) { if (p.axis === 'x') p.mesh.position.x = -limit; else p.mesh.position.z = -limit; }
                            else if (p.direction < 0 && currentPos < -limit) { if (p.axis === 'x') p.mesh.position.x = limit; else p.mesh.position.z = limit; }
                         }
                         break;
                     case 'waiting':
                         p.waitTimer -= deltaTime;
                         if (p.waitTimer <= 0) {
                             p.state = 'crossing'; p.crossingTarget = new THREE.Vector3().copy(p.mesh.position);
                             const crossingDist = roadWidth + sidewalkWidth * 0.4;
                             if (p.axis === 'x') {
                                 const currentStreetX = Math.round(p.mesh.position.x / (buildingBlockSize + streetWidth)) * (buildingBlockSize + streetWidth);
                                 const zDir = p.currentSidewalkPos > currentStreetX ? 1 : -1; // Check if Z > 0 relative to street center? This seems wrong. Should be based on which sidewalk Z.
                                 // Simpler: cross perpendicular to current sidewalk Z
                                 const zDirCross = p.currentSidewalkPos > streetCrossPos ? -1 : 1; // If on +Z sidewalk, cross to -Z sidewalk etc. No, streetCrossPos is X here.
                                 const zDirCrossFinal = (p.mesh.position.z > Math.round(p.mesh.position.z / (buildingBlockSize+streetWidth))*(buildingBlockSize+streetWidth)) ? -1 : 1; // If current Z > street Z center, cross south


                                 p.crossingTarget.z += crossingDist * zDirCrossFinal; // Need to determine correct Z direction
                                 p.crossingTarget.x = currentStreetX - (roadWidth / 2 + sidewalkWidth * 0.2) * p.direction;
                             } else {
                                 const currentStreetZ = Math.round(p.mesh.position.z / (buildingBlockSize + streetWidth)) * (buildingBlockSize + streetWidth);
                                 const xDirCrossFinal = (p.mesh.position.x > Math.round(p.mesh.position.x / (buildingBlockSize+streetWidth))*(buildingBlockSize+streetWidth)) ? -1 : 1; // If current X > street X center, cross west

                                 p.crossingTarget.x += crossingDist * xDirCrossFinal; // Need to determine correct X direction
                                 p.crossingTarget.z = currentStreetZ - (roadWidth / 2 + sidewalkWidth * 0.2) * p.direction;
                             }
                             p.mesh.lookAt(p.crossingTarget.x, p.mesh.position.y, p.crossingTarget.z);
                         }
                         break;
                     case 'crossing':
                         const moveVector = new THREE.Vector3().subVectors(p.crossingTarget, p.mesh.position);
                         const distanceToTarget = moveVector.length();
                         if (distanceToTarget < 0.1) {
                             p.state = 'walking'; p.axis = p.axis === 'x' ? 'z' : 'x'; p.direction = Math.random() < 0.5 ? 1 : -1;
                             p.sidewalkOffset = (Math.random() - 0.5) * (sidewalkWidth * 0.6);
                             if (p.axis === 'x') {
                                 const streetIndexZ = Math.round(p.mesh.position.z / (buildingBlockSize + streetWidth));
                                 const sideZ = p.mesh.position.z > streetIndexZ * (buildingBlockSize + streetWidth) ? 1 : -1;
                                 p.currentSidewalkPos = streetIndexZ * (buildingBlockSize + streetWidth) + sideZ * (roadWidth/2 + sidewalkWidth/2);
                                 p.mesh.position.z = p.currentSidewalkPos + p.sidewalkOffset;
                                 p.mesh.rotation.y = p.direction > 0 ? 0 : Math.PI;
                             } else {
                                 const streetIndexX = Math.round(p.mesh.position.x / (buildingBlockSize + streetWidth));
                                 const sideX = p.mesh.position.x > streetIndexX * (buildingBlockSize + streetWidth) ? 1 : -1;
                                 p.currentSidewalkPos = streetIndexX * (buildingBlockSize + streetWidth) + sideX * (roadWidth/2 + sidewalkWidth/2);
                                 p.mesh.position.x = p.currentSidewalkPos + p.sidewalkOffset;
                                 p.mesh.rotation.y = p.direction > 0 ? -Math.PI / 2 : Math.PI / 2;
                             }
                         } else {
                             moveVector.normalize().multiplyScalar(p.speed * crossingSpeedFactor * deltaTime);
                             p.mesh.position.add(moveVector);
                         }
                         break;
                 }
             });
        }

        // --- Traffic Light Logic ---
        function setTrafficLightState(trafficLight, state) { /* ... (same) ... */
            const darkIntensity = 0.1;
            trafficLight.state = state;
            trafficLight.materials.red.color.setScalar(state === 'red' ? 1 : darkIntensity);
            trafficLight.materials.yellow.color.setScalar(state === 'yellow' ? 1 : darkIntensity);
            trafficLight.materials.green.color.setScalar(state === 'green' ? 1 : darkIntensity);
         }
        function updateTrafficLights(deltaTime) { /* ... (same logic, maybe slightly simplified timing) ... */
             const redDuration = 8; const greenDuration = 8; const yellowDuration = 2;
             const cycleDuration = redDuration + greenDuration + yellowDuration;

             trafficLights.forEach(tl => {
                 tl.timer += deltaTime;
                 const timeInCycle = tl.timer % cycleDuration;
                 const currentState = tl.state; // Store current state before potential change

                 if (currentState === 'green' && timeInCycle >= greenDuration) {
                     setTrafficLightState(tl, 'yellow');
                 } else if (currentState === 'yellow' && timeInCycle >= greenDuration + yellowDuration) {
                     setTrafficLightState(tl, 'red');
                 } else if (currentState === 'red' && timeInCycle >= cycleDuration) { // Use >= cycleDuration for wrap check
                     // Timer wrapped, should be green now
                     setTrafficLightState(tl, 'green');
                     tl.timer = timeInCycle; // Reset timer relative to cycle start
                 } else if (currentState === 'red' && timeInCycle < greenDuration) {
                     // Handles starting in red phase and timer wrapping correctly
                     if (tl.timer > cycleDuration) { // Ensure timer actually wrapped
                         setTrafficLightState(tl, 'green');
                     }
                 }
                 // Initial state check on first frame
                  if (tl.timer < deltaTime * 2) { // Check near beginning
                      if (timeInCycle >= greenDuration + yellowDuration) setTrafficLightState(tl, 'red');
                      else if (timeInCycle >= greenDuration) setTrafficLightState(tl, 'yellow');
                      else setTrafficLightState(tl, 'green');
                  }
             });
         }

        // --- Day/Night Cycle ---
        function updateDayNightCycle(deltaTime) {
            timeOfDay += deltaTime / dayDuration;
            timeOfDay %= 1;
            // ... (Sun position update - same) ...
            const angle = timeOfDay * Math.PI * 2 - Math.PI / 2;
            sunLight.position.x = 120 * Math.cos(angle);
            sunLight.position.y = 100 * Math.sin(angle);
            sunLight.position.z = 70 * Math.cos(angle * 0.5);
            sunLight.target.position.set(0, 0, 0);


            // Light Intensity & Color (same logic)
            // ... (intensityFactor, currentSunIntensity, currentAmbientIntensity) ...
            const dayIntensity = 1.8; const nightIntensity = 0.05;
            const ambientDay = 0.7; const ambientNight = 0.08;
            const intensityFactor = Math.max(0, Math.sin(timeOfDay * Math.PI));
            const currentSunIntensity = nightIntensity + (dayIntensity - nightIntensity) * intensityFactor;
            const currentAmbientIntensity = ambientNight + (ambientDay - ambientNight) * intensityFactor;
            sunLight.intensity = currentSunIntensity;
            ambientLight.intensity = currentAmbientIntensity;

            // Background Color (same logic)
            // ... (dayColor, duskColor, nightColor, bgColor lerp) ...
             const dayColor = new THREE.Color(0x87CEEB); const duskColor = new THREE.Color(0xFF7F50); const nightColor = new THREE.Color(0x000022);
             let bgColor = scene.background; // Modify existing color object
             if (timeOfDay < 0.25) bgColor.lerpColors(nightColor, duskColor, timeOfDay / 0.25);
             else if (timeOfDay < 0.5) bgColor.lerpColors(duskColor, dayColor, (timeOfDay - 0.25) / 0.25);
             else if (timeOfDay < 0.75) bgColor.lerpColors(dayColor, duskColor, (timeOfDay - 0.5) / 0.25);
             else bgColor.lerpColors(duskColor, nightColor, (timeOfDay - 0.75) / 0.25);


            // Sun Color (same logic)
            // ... (daySunColor, duskSunColor, nightSunColor, sunLight.color lerp) ...
            const daySunColor = new THREE.Color(0xffffee); const duskSunColor = new THREE.Color(0xffaa88); const nightSunColor = new THREE.Color(0xccccff);
            if (timeOfDay < 0.25) sunLight.color.lerpColors(nightSunColor, duskSunColor, timeOfDay / 0.25);
            else if (timeOfDay < 0.5) sunLight.color.lerpColors(duskSunColor, daySunColor, (timeOfDay - 0.25) / 0.25);
            else if (timeOfDay < 0.75) sunLight.color.lerpColors(daySunColor, duskSunColor, (timeOfDay - 0.5) / 0.25);
            else sunLight.color.lerpColors(duskSunColor, nightSunColor, (timeOfDay - 0.75) / 0.25);


            // Streetlights / Headlights
            const isNight = intensityFactor < 0.15;
            const lightFadeFactor = deltaTime * 3.0; // Faster fade

            streetLights.forEach(sl => {
                const targetIntensity = isNight ? sl.intensity : 0;
                sl.light.intensity += (targetIntensity - sl.light.intensity) * lightFadeFactor;
                // Cannot easily update instanced bulb material emissiveness here
                // If non-instanced, this would work:
                // sl.meshMaterial.emissive.setHex(sl.light.intensity > 0.1 ? 0xffaa44 : 0x000000);
                // sl.meshMaterial.emissiveIntensity = Math.min(1, sl.light.intensity / sl.intensity * 2);
            });

            cars.forEach(car => {
                 const targetIntensity = isNight ? car.headlightIntensity : 0;
                 car.headlights.forEach(light => {
                     light.intensity += (targetIntensity - light.intensity) * lightFadeFactor;
                 });
                 // Update emissive material for the headlight meshes
                 car.headlightMaterials.forEach(mat => {
                    mat.emissive.setHex(targetIntensity > 1 ? 0xffffff : 0x000000);
                    mat.emissiveIntensity = Math.min(1, targetIntensity / car.headlightIntensity * 2);
                 });
            });
        }

        // --- Window Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate(time) { // time is passed by requestAnimationFrame
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // FPS Calculation
            frameCount++;
            if (time >= lastFPSTime + 1000) {
                fpsElement.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastFPSTime = time;
            }

            controls.update();
            updateCars(deltaTime);
            updatePedestrians(deltaTime);
            updateTrafficLights(deltaTime);
            updateDayNightCycle(deltaTime);

            renderer.render(scene, camera);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>
